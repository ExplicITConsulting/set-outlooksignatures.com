{%- assign all_pages = site.pages -%}
{%- for collection in site.collections -%}
  {%- assign all_pages = all_pages | concat: collection.docs -%}
{%- endfor -%}

{%- for lang_code in site.languages -%}
  {%- assign current_page_url = page.url -%}
  {%- assign alt_url = nil -%}

  {%- if page.lang == site.default_lang -%}
    {%- assign alt_url = '/' | append: lang_code | append: current_page_url -%}
  {%- elsif lang_code == site.default_lang -%}
    {%- assign current_prefix = '/' | append: page.lang | append: '/' -%}
    {%- assign alt_url = current_page_url | replace_first: current_prefix, '/' -%}
  {%- else -%}
    {%- assign current_prefix = '/' | append: page.lang | append: '/' -%}
    {%- assign alt_prefix = '/' | append: lang_code | append: '/' -%}
    {%- assign alt_url = current_page_url | replace_first: current_prefix, alt_prefix -%}
  {%- endif -%}

  {%- assign alt_page = all_pages | where: "url", alt_url | first -%}

  {%- if alt_page and lang_code != page.lang -%}
    <link rel="alternate" hreflang="{{ lang_code }}" href="{{ site.url }}{{ alt_page.url }}" />
  {%- endif -%}
{%- endfor -%}

{%- if page.lang == site.default_lang -%}
  <link rel="alternate" hreflang="x-default" href="{{ site.url }}{{ page.url }}" />
{%- else -%}
  {%- assign current_prefix = '/' | append: page.lang | append: '/' -%}
  {%- assign default_url = page.url | replace_first: current_prefix, '/' -%}
  {%- assign default_page = all_pages | where: "url", default_url | first -%}
  {%- if default_page -%}
    <link rel="alternate" hreflang="x-default" href="{{ site.url }}{{ default_page.url }}" />
  {%- endif -%}
{%- endif -%}


<script>
  document.addEventListener('DOMContentLoaded', function () {
    const languageDropdown = document.getElementById('languageDropdown');
    const availableLanguages = Array.from(languageDropdown ? languageDropdown.options : []).map((option) => option.value);
    if (availableLanguages.length === 0) {
      availableLanguages.push('en', 'de');
    }

    let preferredLanguage = localStorage.getItem("languageDropdownValue");

    if (preferredLanguage && availableLanguages.includes(preferredLanguage)) {
      // Valid preferredLanguage from localStorage, use it.
    } else {
      if (navigator.languages && navigator.languages.length > 0) {
        for (let i = 0; i < navigator.languages.length; i++) {
          const browserLang = navigator.languages[i].toLowerCase().split("-")[0];
          if (availableLanguages.includes(browserLang)) {
            preferredLanguage = browserLang;
            break;
          }
        }
      }

      if (!preferredLanguage) {
        const fallbackLang = (navigator.language || navigator.userLanguage || "").toLowerCase().split("-")[0];
        if (availableLanguages.includes(fallbackLang)) {
          preferredLanguage = fallbackLang;
        }
      }

      if (!preferredLanguage) {
        preferredLanguage = "en";
      }
    }

    if (languageDropdown) {
      languageDropdown.value = preferredLanguage;
    }

    // --- Start of dynamically fetched bot detection code ---
    const CRAWLER_USER_AGENTS_JSON_URL = 'https://raw.githubusercontent.com/monperrus/crawler-user-agents/master/crawler-user-agents.json';
    let compiledBotRegexes = []; // This array will store compiled RegExp objects
    let assumeBotOnFetchFailure = false; // New flag to indicate if fetch failed

    /**
     * Compiles regex patterns from the fetched JSON data into RegExp objects.
     * Handles the (?i) flag by using JavaScript's 'i' (case-insensitive) flag.
     * @param {Array<Object>} jsonData - The array of objects from crawler-user-agents.json
     * @returns {Array<RegExp>} An array of compiled RegExp objects.
     */
    function compileRegexes(jsonData) {
      return jsonData.map(entry => {
        try {
          // Remove the (?i) prefix if present, as 'i' flag handles case-insensitivity
          let pattern = entry.pattern;
          let flags = 'i'; // Always case-insensitive as per (?i) convention in the JSON
          if (pattern.startsWith('(?i)')) {
            pattern = pattern.substring(4);
          }
          return new RegExp(pattern, flags);
        } catch (e) {
          console.warn('Invalid regex pattern from crawler-user-agents.json:', entry.pattern, e);
          return null; // Return null for invalid patterns
        }
      }).filter(Boolean); // Filter out any null entries (invalid patterns)
    }

    /**
     * Checks if the given userAgent string matches any of the compiled bot regexes.
     * @param {string} userAgent - The user agent string to check.
     * @returns {boolean} True if the user agent is a bot, false otherwise.
     */
    function isBot(userAgent) {
      if (!userAgent || compiledBotRegexes.length === 0) {
        // If no user agent or no patterns loaded, default to not a bot for safety
        // This case is now mostly covered by assumeBotOnFetchFailure
        return false;
      }
      for (let i = 0; i < compiledBotRegexes.length; i++) {
        if (compiledBotRegexes[i].test(userAgent)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Encapsulates the original redirection logic.
     * This function will be called once the bot patterns are loaded (or if loading fails).
     */
    function executeRedirectionLogic() {
      const currentPathname = window.location.pathname;
      const currentHostname = window.location.hostname;
      const currentProtocol = window.location.protocol;
      const currentSearch = window.location.search;
      const currentHash = window.location.hash;

      function normalizePathForComparison(path) {
        if (!path) return '/';
        let normalized = path.replace(/\/\/+/g, '/');
        if (normalized.length > 1 && normalized.endsWith('/')) {
          normalized = normalized.slice(0, -1);
        }
        if (!normalized.startsWith('/')) {
          normalized = '/' + normalized;
        }
        return normalized;
      }

      let baseContentPath = '/';
      const anyTwoLetterFolderRegex = /^\/([a-z]{2})(\/.*)?$/;
      const pathSegmentMatch = currentPathname.match(anyTwoLetterFolderRegex);

      if (pathSegmentMatch) {
        baseContentPath = pathSegmentMatch[2] || '/';
      } else {
        baseContentPath = currentPathname;
      }
      baseContentPath = normalizePathForComparison(baseContentPath);

      let targetPathname;
      if (preferredLanguage === "en") {
        targetPathname = baseContentPath;
      } else {
        targetPathname = `/${preferredLanguage}${baseContentPath === '/' ? '/' : baseContentPath}`;
      }
      targetPathname = normalizePathForComparison(targetPathname);

      const normalizedCurrentPathForComparison = normalizePathForComparison(currentPathname);
      const normalizedTargetPathForComparison = normalizePathForComparison(targetPathname);

      if (normalizedCurrentPathForComparison !== normalizedTargetPathForComparison) {
        // --- Bot detection check before redirection ---
        // If fetch failed, or if isBot returns true, skip redirection
        if (assumeBotOnFetchFailure || isBot(navigator.userAgent)) {
          const reason = assumeBotOnFetchFailure ? "fetch failed (assuming bot)" : "bot detected";
          console.log(`Skipping redirection due to ${reason}.`);
          return; // Prevent redirection for bots or failed fetch
        }
        // --- End bot detection check ---

        const currentFullUrl = `${currentProtocol}//${currentHostname}${currentPathname}${currentSearch}${currentHash}`;
        const targetFullUrl = `${currentProtocol}//${currentHostname}${targetPathname}${currentSearch}${currentHash}`;
        const fallbackToEnglishFullUrl = `${currentProtocol}//${currentHostname}${baseContentPath}${currentSearch}${currentHash}`;

        fetch(targetFullUrl, { method: 'HEAD' })
          .then(response => {
            if (response.ok) {
              window.location.replace(targetFullUrl);
            } else {
              if (normalizedCurrentPathForComparison !== normalizePathForComparison(baseContentPath)) {
                window.location.replace(fallbackToEnglishFullUrl);
              }
            }
          })
          .catch(error => {
            console.error('Error during HEAD request for target URL:', error);
            if (normalizedCurrentPathForComparison !== normalizePathForComparison(baseContentPath)) {
              window.location.replace(fallbackToEnglishFullUrl);
            }
          });
      } else {
        // No redirect needed, the current page is already the correct preferred language
      }
    }

    // Fetch the crawler-user-agents JSON dynamically
    fetch(CRAWLER_USER_AGENTS_JSON_URL)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        compiledBotRegexes = compileRegexes(data);
        assumeBotOnFetchFailure = false; // Reset if successful
        console.log(`Successfully loaded and compiled ${compiledBotRegexes.length} bot patterns.`);
        executeRedirectionLogic(); // Proceed with redirection logic after patterns are loaded
      })
      .catch(error => {
        console.error('Failed to load crawler user agents JSON. Assuming it is a bot and skipping redirection:', error);
        compiledBotRegexes = []; // Clear any potentially partial or old patterns
        assumeBotOnFetchFailure = true; // Set the flag to assume bot
        executeRedirectionLogic(); // Proceed, but it will now skip redirection due to the flag
      });
    // --- End of dynamically fetched bot detection code ---

  });
</script>


<script>
  document.addEventListener("DOMContentLoaded", function () {
    const links = document.querySelectorAll("a[href]");

    const externalLinkSvg = `
            <svg xmlns="http://www.w3.org/2000/svg" width="0.75em" height="0.75em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              <polyline points="15 3 21 3 21 9"></polyline>
              <line x1="10" y1="14" x2="21" y2="3"></line>
            </svg>
          `;

    links.forEach(link => {
      try {
        const url = new URL(link.href, window.location.href);

        if (url.hostname.toLowerCase() !== window.location.hostname.toLowerCase()) {
          link.setAttribute("target", "_blank");
        }

        if ((link.getAttribute("target") || "").toLowerCase() === "_blank") {
          let targetElement = link;
          const buttonChild = link.querySelector('button');
          if (buttonChild) {
            targetElement = buttonChild;
          }

          if (!targetElement.querySelector(".icon svg")) {
            const iconSpan = document.createElement("span");
            iconSpan.classList.add("icon");
            iconSpan.style.marginLeft = "0.2em";
            iconSpan.style.verticalAlign = "middle";
            iconSpan.innerHTML = externalLinkSvg.trim();
            targetElement.appendChild(iconSpan);
          }
        }
      } catch (e) {
        // Invalid URL, skip
      }
    });
  });
</script>


<script>
  document.addEventListener("DOMContentLoaded", function () {
    const headings = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

    headings.forEach(function (heading) {
      if (!heading.id) {
        // Generate a slug from the heading text
        const slug = heading.textContent
          .toLowerCase()
          .trim()
          .replace(/[^\w\s-]/g, '') // Remove non-word characters
          .replace(/\s+/g, '-');    // Replace spaces with dashes

        // Ensure uniqueness by appending a number if needed
        let uniqueSlug = slug;
        let counter = 1;
        while (document.getElementById(uniqueSlug)) {
          uniqueSlug = `${slug}-${counter++}`;
        }
        heading.id = uniqueSlug;
      }

      const anchor = document.createElement("a");
      anchor.href = `#${heading.id}`;
      anchor.className = "anchor-link";
      anchor.innerHTML = "🔗";

      heading.insertBefore(anchor, heading.firstChild);
    });
  });
</script>