{%- assign all_pages = site.pages -%}
{%- for collection in site.collections -%}
{%- assign all_pages = all_pages | concat: collection.docs -%}
{%- endfor -%}

{%- comment -%} Add the self-referencing hreflang tag here {%- endcomment %}
<link rel="alternate" hreflang="{{ page.lang }}" href="{{ site.url }}{{ page.url }}" />

{%- for lang_code in site.languages -%}
{%- assign current_page_url = page.url -%}
{%- assign alt_url = nil -%}

{%- if page.lang == site.default_lang -%}
{%- assign alt_url = '/' | append: lang_code | append: current_page_url -%}
{%- elsif lang_code == site.default_lang -%}
{%- assign current_prefix = '/' | append: page.lang | append: '/' -%}
{%- assign alt_url = current_page_url | replace_first: current_prefix, '/' -%}
{%- else -%}
{%- assign current_prefix = '/' | append: page.lang | append: '/' -%}
{%- assign alt_prefix = '/' | append: lang_code | append: '/' -%}
{%- assign alt_url = current_page_url | replace_first: current_prefix, alt_prefix -%}
{%- endif -%}

{%- assign alt_page = all_pages | where: "url", alt_url | first -%}

{%- if alt_page and lang_code != page.lang %}
<link rel="alternate" hreflang="{{ lang_code }}" href="{{ site.url }}{{ alt_page.url }}" />
{%- endif -%}
{%- endfor -%}

{%- if page.lang == site.default_lang %}
<link rel="alternate" hreflang="x-default" href="{{ site.url }}{{ page.url }}" />
{%- else -%}
{%- assign current_prefix = '/' | append: page.lang | append: '/' -%}
{%- assign default_url = page.url | replace_first: current_prefix, '/' -%}
{%- assign default_page = all_pages | where: "url", default_url | first -%}
{%- if default_page %}
<link rel="alternate" hreflang="x-default" href="{{ site.url }}{{ default_page.url }}" />
{%- endif -%}
{%- endif -%}


<script>
  document.addEventListener('DOMContentLoaded', function () {
    const languageDropdown = document.getElementById('languageDropdown');
    const availableLanguages = Array.from(languageDropdown ? languageDropdown.options : []).map((option) => option.value);
    let preferredLanguage = localStorage.getItem("languageDropdownValue") || "en";
    if (languageDropdown) languageDropdown.value = preferredLanguage;

    // Global object to hold the map of alternate paths by language
    let pathMap = {};

    /**
     * Fetches and parses the sitemap.xml to build a map of alternate paths.
     */
    async function loadSitemapPaths() {
      try {
        const response = await fetch('/sitemap.xml');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const xmlText = await response.text();
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, "text/xml");

        const urls = xmlDoc.querySelectorAll('url');
        urls.forEach(urlElement => {
          const locElement = urlElement.querySelector('loc');
          if (!locElement) return;

          const locUrl = new URL(locElement.textContent);
          const locPath = normalizePathForComparison(locUrl.pathname);
          const baseContentPath = normalizePathWithoutLang(locPath);

          const alternateLinks = urlElement.querySelectorAll('xhtml\\:link, link[rel="alternate"]');
          const languagePaths = {};

          alternateLinks.forEach(link => {
            const lang = link.getAttribute('hreflang');
            const href = link.getAttribute('href');
            if (lang && href) {
              try {
                languagePaths[lang] = normalizePathForComparison(new URL(href).pathname);
              } catch (e) {
                console.error('Invalid URL in sitemap <xhtml:link>:', href);
              }
            }
          });

          if (baseContentPath) {
            pathMap[baseContentPath] = languagePaths;
          }
        });

        // console.log('Path map loaded successfully from sitemap:', pathMap);
      } catch (error) {
        console.error('Could not load or parse sitemap:', error);
      }
    }

    /**
     * Rewrites all internal links on the page to the correct language.
     */
    function rewriteInternalLinks() {
      const currentHostname = window.location.hostname;

      document.querySelectorAll('a').forEach(link => {
        try {
          const href = link.getAttribute('href');
          if (!href || href.startsWith('#') || href.startsWith('mailto:') || href.startsWith('tel:')) return;

          const url = new URL(href, window.location.href);

          if (url.hostname === currentHostname) {
            const currentLinkPath = normalizePathForComparison(url.pathname);
            const baseContentPath = normalizePathWithoutLang(currentLinkPath);

            // Use the base path to look up the alternate path in the map
            const alternatePaths = pathMap[baseContentPath];
            if (alternatePaths && alternatePaths[preferredLanguage]) {
              const targetPath = alternatePaths[preferredLanguage];

              // The target page exists, so rewrite the link
              const newHref = new URL(targetPath, window.location.href);
              newHref.hash = url.hash;
              newHref.search = url.search;
              link.setAttribute('href', newHref.href);
            } else {
              // console.log(`No alternate path found for base path ${baseContentPath} in language ${preferredLanguage}. Leaving link as is.`);
            }
          }
        } catch (e) {
          console.error('Error rewriting link:', link, e);
        }
      });
    }

    /**
    * Extracts the base path without the language prefix.
    */
    function normalizePathWithoutLang(path) {
      const anyTwoLetterFolderRegex = /^\/([a-z]{2})(?:\/|$)/;
      const langMatch = path.match(anyTwoLetterFolderRegex);
      if (langMatch) {
        // Return the path with the language prefix replaced by a single slash
        const baseContentPath = path.replace(anyTwoLetterFolderRegex, '/');
        // Ensure the root path is just '/'
        return baseContentPath === '/' ? '/' : baseContentPath.replace(/\/+$/, '');
      }
      return path;
    }

    /**
     * Extracts the base path without the language prefix.
     */
    function normalizePathWithoutLang(path) {
      const anyTwoLetterFolderRegex = /^\/([a-z]{2})(?:\/|$)/;
      const langMatch = path.match(anyTwoLetterFolderRegex);
      if (langMatch) {
        // Corrected to remove the language code and return the rest of the path
        const baseContentPath = path.replace(anyTwoLetterFolderRegex, '/');
        return baseContentPath === '/' ? '/' : baseContentPath.replace(/\/$/, '');
      }
      return path;
    }

    /**
     * Executes the redirection logic based on preferred language and current URL.
     */
    async function executeRedirectionLogic() {
      await loadSitemapPaths();

      const currentPathname = normalizePathForComparison(window.location.pathname);
      const baseContentPath = normalizePathWithoutLang(currentPathname);
      const currentHash = window.location.hash;
      const currentHostname = window.location.hostname;
      const currentProtocol = window.location.protocol;
      const currentSearch = window.location.search;

      const alternatePaths = pathMap[baseContentPath];
      const targetPathnamePreferredLang = alternatePaths ? alternatePaths[preferredLanguage] : null;

      if (targetPathnamePreferredLang) {
        if (currentPathname !== normalizePathForComparison(targetPathnamePreferredLang)) {
          const finalRedirectUrl = `${currentProtocol}//${currentHostname}${targetPathnamePreferredLang}${currentSearch}${currentHash}`;

          // console.log('Target document exists. Redirecting to:', finalRedirectUrl);

          window.location.replace(finalRedirectUrl);

          return;
        }
      }

      //console.log('Current URL already matches or no alternate found. Rewriting links...');

      rewriteInternalLinks();
    }

    executeRedirectionLogic();
  });
</script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const links = document.querySelectorAll("a[href]");

    const externalLinkSvg = `
            <svg xmlns="http://www.w3.org/2000/svg" width="0.75em" height="0.75em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              <polyline points="15 3 21 3 21 9"></polyline>
              <line x1="10" y1="14" x2="21" y2="3"></line>
            </svg>
          `;

    links.forEach(link => {
      try {
        link.classList.add("mtrcs-external-link");

        const url = new URL(link.href, window.location.href);

        if (url.hostname.toLowerCase() !== window.location.hostname.toLowerCase()) {
          link.setAttribute("target", "_blank");
        }

        if ((link.getAttribute("target") || "").toLowerCase() === "_blank") {
          let targetElement = link;
          const buttonChild = link.querySelector('button');
          if (buttonChild) {
            targetElement = buttonChild;
          }

          if (!targetElement.querySelector("svg[data-external-link-icon]")) {
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(externalLinkSvg, "image/svg+xml");
            const svgElement = svgDoc.documentElement;

            // Set attributes for styling or identification directly on the SVG element
            //svgElement.style.verticalAlign = "middle";
            svgElement.setAttribute("data-external-link-icon", "true"); // For easy selection later

            // Create a text node for the non-breaking space
            const nbspNode = document.createTextNode('\u00A0'); // Unicode for &nbsp;

            targetElement.appendChild(nbspNode);
            targetElement.appendChild(svgElement);
          }
        }
      } catch (e) {
        // Invalid URL, skip
      }
    });
  });
</script>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('p + ul, p + ol').forEach(list => {
      const prev = list.previousElementSibling;
      if (prev && prev.tagName === 'P') {
        prev.style.marginBottom = '0';
        list.style.marginTop = '0';
      }
    });
  });
</script>


<script>
  document.addEventListener("DOMContentLoaded", function () {
    const headings = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

    headings.forEach(function (heading) {
      // Check if the heading already has an ID, which should be the case
      // after the Jekyll plugin runs.
      if (heading.id) {
        const anchor = document.createElement("a");
        anchor.href = `#${heading.id}`;
        anchor.className = "anchor-link";
        anchor.innerHTML = "ðŸ”—"; // Or use an SVG for better styling

        // Insert the anchor link as the first child of the heading
        heading.insertBefore(anchor, heading.firstChild);
      }
    });
  });
</script>


<!-- Start mtrcs code -->
<script>
  document.addEventListener("DOMContentLoaded", function () {
    const links = document.querySelectorAll("a[href]");

    links.forEach(link => {
      try {
        link.classList.add("mtrcs-external-link");
      } catch (e) {
        // Do nothing
      }
    });
  });

  var _paq = window._paq = window._paq || [];
  _paq.push(["setRequestMethod", "POST"]);
  _paq.push(["disableCookies"]);
  _paq.push(["deleteCookies"]);
  _paq.push(["disableAlwaysUseSendBeacon"]);
  _paq.push(["disableQueueRequest"]);
  _paq.push(["setDocumentTitle", document.domain + ": " + document.title]);
  _paq.push(["setCookieDomain", "*.set-outlooksignatures.com"]);
  _paq.push(["setDomains", ["*.set-outlooksignatures.com"]]);
  _paq.push(['enableHeartBeatTimer']);
  _paq.push(['setLinkClasses', "mtrcs-external-link"]);
  _paq.push(['trackPageView']);
  _paq.push(['trackVisibleContentImpressions']);
  _paq.push(['enableLinkTracking']);


  (function () {
    var u = "//mtrcs.set-outlooksignatures.com/";
    _paq.push(["setTrackerUrl", u + "poop.php"]);
    _paq.push(["setSiteId", "1"]);
    var d = document, g = d.createElement("script"), s = d.getElementsByTagName("script")[0];
    g.type = "text/javascript"; g.async = true; g.defer = true; g.src = u + "poop.js"; s.parentNode.insertBefore(g, s);
  })();
</script>

<noscript>
  <p><img referrerpolicy="no-referrer-when-downgrade"
      src="//mtrcs.set-outlooksignatures.com/poop.php?idsite=1&amp;rec=1" style="border:0;" alt="" /></p>
</noscript>
<!-- End mtrcs code -->