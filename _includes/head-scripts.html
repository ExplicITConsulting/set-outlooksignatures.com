<!-- mtrcs js code -->
<script>
  var _paq = window._paq = window._paq || [];
  _paq.push(["setRequestMethod", "POST"]);
  _paq.push(["disableCookies"]);
  _paq.push(["deleteCookies"]);
  _paq.push(["disableAlwaysUseSendBeacon"]);
  _paq.push(["disableQueueRequest"]);
  _paq.push(["setDocumentTitle", document.domain + ": " + document.title]);
  _paq.push(["setCookieDomain", "*.set-outlooksignatures.com"]);
  _paq.push(["setDomains", ["*.set-outlooksignatures.com"]]);
  _paq.push(['enableHeartBeatTimer']);
  _paq.push(['setLinkClasses', ["mtrcs-external-link"]]);
  _paq.push(['setDownloadClasses', ["mtrcs-download"]]);
  _paq.push(['trackPageView']);
  _paq.push(['trackVisibleContentImpressions', true]);
  _paq.push(['enableLinkTracking']);


  (
    function () {
      var u = "//mtrcs.set-outlooksignatures.com/";
      _paq.push(["setTrackerUrl", u + "mtrcs.php"]);
      _paq.push(["setSiteId", "1"]);
      var d = document;
      g = d.createElement("script");
      s = d.getElementsByTagName("script")[0];
      g.type = "text/javascript";
      g.async = true;
      g.defer = true;
      g.src = u + "mtrcs.js";
      s.parentNode.insertBefore(g, s);
    }
  )();
</script>


<!-- mtrcs no js code -->
<noscript>
  <p>
    <img referrerpolicy="no-referrer-when-downgrade"
      src='//mtrcs.set-outlooksignatures.com/mtrcs.php?idsite=1&rec=1&action_name=page_view&url={{ site.url }}{{ page.url | relative_url }}&rand={{ "now" | date: "%s" }}&apiv=1'
      style="border:0;" alt="" />
  </p>
</noscript>


<!-- mtrcs youtube code -->
<script>
  document.addEventListener('DOMContentLoaded', async () => {
    const playerElement = document.getElementById('youtube-video-player');
    if (playerElement) {
      // Define the onYouTubeIframeAPIReady function before loading the script.
      // The YouTube API will call this function automatically once it's loaded.
      window.onYouTubeIframeAPIReady = () => {
        // Create a new YT.Player object for the iframe with id="youtube-video-player"
        window.player = new YT.Player('youtube-video-player', {
          events: {
            'onStateChange': onPlayerStateChange
          }
        });
      };

      // This function is called by the YouTube API whenever the player's state changes.
      function onPlayerStateChange(event) {
        const videoTitle = "Set-OutlookSignatures Demo"; // Customize this
        const currentTime = window.player.getCurrentTime();

        if (event.data === YT.PlayerState.PLAYING) {
          // Track when the video starts playing
          _paq.push(['trackEvent', 'Video', 'Play', videoTitle, Math.round(currentTime)]);
        } else if (event.data === YT.PlayerState.PAUSED) {
          // Track when the video is paused
          _paq.push(['trackEvent', 'Video', 'Pause', videoTitle, Math.round(currentTime)]);
        } else if (event.data === YT.PlayerState.ENDED) {
          // Track when the video ends
          _paq.push(['trackEvent', 'Video', 'Ended', videoTitle, Math.round(currentTime)]);
        }
      }

      // Dynamically create and append the script tag to the body.
      // This is the key step that loads the script only when needed.
      const script = document.createElement('script');
      script.src = 'https://www.youtube.com/iframe_api';
      document.body.appendChild(script);
    }
  });
</script>


<!-- Add html hash to language switcher links -->
<script>
  document.addEventListener('DOMContentLoaded', async () => {
    // Define a function to handle the link updates
    const updateLanguageLinks = () => {
      const currentHash = window.location.hash;
      const languageLinks = document.querySelectorAll('a[data-base-url]');

      languageLinks.forEach(link => {
        const baseHref = link.getAttribute('data-base-url');
        link.href = baseHref + currentHash;
      });
    };

    // Initial call when the DOM is ready
    updateLanguageLinks();

    // Listen for hash changes and update the links again
    window.addEventListener('hashchange', updateLanguageLinks);
  });
</script>


<!-- Code for delete button in notifications -->
<script>
  document.addEventListener('DOMContentLoaded', async () => {
    (document.querySelectorAll('.notification .delete') || []).forEach(($delete) => {
      const $notification = $delete.parentNode;

      $delete.addEventListener('click', () => {
        $notification.parentNode.removeChild($notification);
      });
    });
  });
</script>


<!-- Button animation -->
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const buttons = document.querySelectorAll('.button');
    const animationDuration = 1000;
    const totalCycle = 5000;
    const staggerDelay = 1000;

    // Set the start time for the entire animation sequence
    const startTime = Date.now();

    // This array stores the absolute time in milliseconds when each button should animate next.
    const nextAnimationTimes = Array.from(buttons).map((_, index) => {
      return startTime + (index * staggerDelay);
    });

    const animateButtons = () => {
      const now = Date.now();
      let nextTimeoutTime = Infinity;

      buttons.forEach((button, index) => {
        const nextTime = nextAnimationTimes[index];

        if (now >= nextTime) {
          button.classList.add('animated-now');

          // This setTimeout is only created when an animation is triggered
          setTimeout(() => {
            button.classList.remove('animated-now');
          }, animationDuration);

          // Update the next animation time for this button
          nextAnimationTimes[index] += totalCycle;
        }

        // Find the time until the *next* earliest animation needs to happen
        const timeUntilNext = nextAnimationTimes[index] - now;
        if (timeUntilNext < nextTimeoutTime) {
          nextTimeoutTime = timeUntilNext;
        }
      });

      // Use a single, self-calling setTimeout to manage the next check.
      // We ensure a minimum delay of 100ms to prevent the browser from becoming unresponsive.
      const delay = Math.max(100, nextTimeoutTime);
      setTimeout(animateButtons, delay);
    };

    // Start the animation loop
    animateButtons();
  });
</script>


<!-- Scrolling customer images banner -->
<script>
  document.addEventListener('DOMContentLoaded', async () => {
    const track = document.querySelector('.scrolling-track');
    const banner = document.querySelector('.scrolling-banner');

    if (!track || !banner) {
      console.warn('Scrolling track or banner element not found. Please ensure the HTML structure is correct.');
      return;
    }

    try {
      const response = await fetch('https://set-outlooksignatures.com/customer-images.txt');
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const text = await response.text();
      let urls = text.split('\n').map(line => line.trim()).filter(Boolean);

      urls = [...new Set(urls)];

      if (urls.length === 0) {
        console.warn('No image URLs found. Banner will not display images.');
        return;
      }

      for (let i = urls.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [urls[i], urls[j]] = [urls[j], urls[i]];
      }

      const originalShuffledUniqueUrls = [...urls];
      const finalUrlsForDOM = [...originalShuffledUniqueUrls, ...originalShuffledUniqueUrls, ...originalShuffledUniqueUrls];

      track.innerHTML = '';
      const imagePromises = finalUrlsForDOM.map(url => {
        return new Promise((resolve) => {
          const img = new Image();
          img.src = url;
          img.alt = `https://${url.split('/').pop()?.split('.').slice(0, -1).join('.')}` || 'Customer Logo';

          img.onload = () => resolve({ img, loaded: true });
          img.onerror = () => {
            console.error(`Failed to load image: ${url}`);
            resolve({ img: null, loaded: false });
          };

          if (img.complete) {
            if (img.naturalHeight > 0) {
              resolve({ img, loaded: true });
            } else {
              resolve({ img: null, loaded: false });
            }
          }
        });
      });

      const loadedImageResults = await Promise.all(imagePromises);
      const imageElements = loadedImageResults.map(result => result.img).filter(img => img !== null);

      if (imageElements.length === 0) {
        console.warn('All images failed to load. Disabling animation.');
        return;
      }

      imageElements.forEach(img => track.appendChild(img));

      requestAnimationFrame(() => {
        const bannerWidth = banner.clientWidth;
        const computedStyle = getComputedStyle(track);
        const gapSize = parseFloat(computedStyle.gap) || 0;

        let scrollDistance = 0;
        for (let i = 0; i < originalShuffledUniqueUrls.length; i++) {
          const img = track.children[i];
          if (img) {
            scrollDistance += img.offsetWidth;
            if (i < originalShuffledUniqueUrls.length - 1) {
              scrollDistance += gapSize;
            }
          }
        }

        if (scrollDistance <= 0 || track.scrollWidth <= bannerWidth + 1) {
          console.warn('Content is not wide enough to scroll. Disabling animation.');
          track.style.animation = 'none';
          return;
        }

        const pixelsPerSecond = 50;
        const animationDuration = scrollDistance / pixelsPerSecond;
        const animationName = 'scroll-full-track-dynamic-' + Date.now();

        let styleSheet = document.getElementById('dynamic-scroll-animation-style');
        if (!styleSheet) {
          styleSheet = document.createElement('style');
          styleSheet.id = 'dynamic-scroll-animation-style';
          document.head.appendChild(styleSheet);
        } else {
          while (styleSheet.sheet && styleSheet.sheet.cssRules.length > 0) {
            styleSheet.sheet.deleteRule(0);
          }
        }

        const keyframesRule = `
          @keyframes ${animationName} {
            from { transform: translateX(0); }
            to { transform: translateX(${-scrollDistance}px); }
          }
        `;
        styleSheet.sheet.insertRule(keyframesRule, styleSheet.sheet.cssRules.length);

        track.style.animation = `${animationName} ${animationDuration}s linear infinite`;
        track.style.animationPlayState = 'running';
      });

    } catch (error) {
      console.error('Failed to fetch or process image URLs:', error);
    }
  });
</script>


<!-- Update download links to latest release of Set-OutlookSignatures -->
<script>
  async function updateDownloadLink() {
    const owner = 'Set-OutlookSignatures';
    const repo = 'Set-OutlookSignatures';
    const repoURL = `https://api.github.com/repos/${owner}/${repo}/releases/latest`;

    try {
      const response = await fetch(repoURL);
      if (!response.ok) {
        throw new Error(`GitHub API request failed with status: ${response.status}`);
      }

      const data = await response.json();
      const firstAsset = data.assets[0];

      if (firstAsset && firstAsset.browser_download_url) {
        const downloadLinks = document.querySelectorAll('.sos-download-link');
        if (downloadLinks.length > 0) {
          downloadLinks.forEach(link => {
            link.href = firstAsset.browser_download_url;
          });
        } else {
          // console.warn('No elements with class "sos-download-link" found.');
        }
      } else {
        console.error('No assets found for the latest release.');
      }
    } catch (error) {
      console.error('Error fetching latest release:', error);
    }
  }

  document.addEventListener('DOMContentLoaded', updateDownloadLink);
</script>


<!-- Add and lazy load background image -->
<style>
  html::before {
    content: "";
    position: fixed;

    /* 1. POSITIONING FOR CENTERING */
    /* Move the top edge to the vertical center */
    top: 50%;
    /* Move the left edge to the horizontal center */
    left: 50%;

    /* 2. RESIZING TO 33% */
    /* Set the width to 33% of the viewport width */
    width: 33vw;
    /* Set the height to 33% of the viewport height */
    height: 33vh;

    /* 3. FINAL ALIGNMENT */
    /* Shifts the element back by half its own width/height to center it */
    transform: translate(-50%, -50%) rotate(-20deg);

    background-repeat: no-repeat;
    background-size: contain;
    background-position: center center;

    pointer-events: none;
    z-index: -2;
    opacity: 0.2;
    filter: var(--bg-filter, none);
  }

  html.loaded::before {
    background-image: url("/assets/images/set-outlooksignatures logo background.png");
  }

  /* Define a new class for dark mode background. This class will be added and removed by JavaScript. */
  html.dark-mode-bg::before {
    --bg-filter: invert(1) hue-rotate(180deg);
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', async () => {
    // Add the 'loaded' class to display the background image.
    document.documentElement.classList.add('loaded');

    // Detect system preference for dark mode.
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

    // Apply dark mode background filter if system prefers dark.
    if (prefersDark) {
      document.documentElement.classList.add('dark-mode-bg');
    }

    // Watch for changes in system preference.
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
      if (event.matches) {
        document.documentElement.classList.add('dark-mode-bg');
      } else {
        document.documentElement.classList.remove('dark-mode-bg');
      }
    });

    // Optional: MutationObserver if other scripts might toggle 'dark-mode-bg' manually.
    const observer = new MutationObserver((mutationsList) => {
      for (const mutation of mutationsList) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          // You could add logic here if needed to respond to manual class changes.
        }
      }
    });

    observer.observe(document.documentElement, { attributes: true });
  });
</script>
