<script>
  document.addEventListener("DOMContentLoaded", function () {
    const links = document.querySelectorAll("a[href]");

    links.forEach(link => {
      try {

        const url = new URL(link.href, window.location.href);

        if (url.hostname.toLowerCase() !== window.location.hostname.toLowerCase()) {
          link.classList.add("mtrcs-external-link");
          link.setAttribute("target", "_blank");
        } else {
          link.classList.add("mtrcs-internal-link");
        }

        if ((link.getAttribute("target") || "").toLowerCase() === "_blank" && !link.classList.contains("no-external-link-icon")) {
          let targetElement = link;
          const buttonChild = link.querySelector('button');
          if (buttonChild) {
            targetElement = buttonChild;
          }

          // Check if the arrow character has already been added
          if (!targetElement.querySelector("span.external-link-arrow")) {
            // Create a span element for the arrow and space
            const arrowSpan = document.createElement("span");
            arrowSpan.className = "external-link-arrow";
            arrowSpan.style.whiteSpace = "nowrap"; // Keep the space and arrow together

            // Add the non-breaking space and the arrow
            arrowSpan.innerHTML = `&nbsp;â†—`;

            targetElement.appendChild(arrowSpan);
          }
        }
      } catch (e) {
        // Invalid URL, skip
      }
    });
  });
</script>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('p + ul, p + ol').forEach(list => {
      const prev = list.previousElementSibling;
      if (prev && prev.tagName === 'P') {
        prev.style.marginBottom = '0';
        list.style.marginTop = '0';
      }
    });
  });
</script>


<script>
  document.addEventListener("DOMContentLoaded", function () {
    const headings = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

    headings.forEach(function (heading) {
      // Check if the heading already has an ID, which should be the case
      // after the Jekyll plugin runs.
      if (heading.id) {
        const anchor = document.createElement("a");
        anchor.href = `#${heading.id}`;
        anchor.className = "anchor-link";
        anchor.innerHTML = "ðŸ”—"; // Or use an SVG for better styling

        // Insert the anchor link as the first child of the heading
        heading.insertBefore(anchor, heading.firstChild);
      }
    });
  });
</script>


<!-- Start mtrcs code -->
<script>
  var _paq = window._paq = window._paq || [];
  _paq.push(["setRequestMethod", "POST"]);
  _paq.push(["disableCookies"]);
  _paq.push(["deleteCookies"]);
  _paq.push(["disableAlwaysUseSendBeacon"]);
  _paq.push(["disableQueueRequest"]);
  _paq.push(["setDocumentTitle", document.domain + ": " + document.title]);
  _paq.push(["setCookieDomain", "*.set-outlooksignatures.com"]);
  _paq.push(["setDomains", ["*.set-outlooksignatures.com"]]);
  _paq.push(['enableHeartBeatTimer']);
  _paq.push(['setLinkClasses', ["mtrcs-external-link", "mtrcs-internal-link"]]);
  _paq.push(['trackPageView']);
  _paq.push(['trackVisibleContentImpressions']);
  _paq.push(['enableLinkTracking']);


  (function () {
    var u = "//mtrcs.set-outlooksignatures.com/";
    _paq.push(["setTrackerUrl", u + "poop.php"]);
    _paq.push(["setSiteId", "1"]);
    var d = document, g = d.createElement("script"), s = d.getElementsByTagName("script")[0];
    g.type = "text/javascript"; g.async = true; g.defer = true; g.src = u + "poop.js"; s.parentNode.insertBefore(g, s);
  })();
</script>

<noscript>
  <p><img referrerpolicy="no-referrer-when-downgrade"
      src="//mtrcs.set-outlooksignatures.com/poop.php?idsite=1&amp;bots=1&amp;rec=1&amp;action_name=page_view&amp;url={{ site.url }}{{ page.url | relative_url }}&amp;rand={{ "
      now" | date: "%s" }}&amp;apiv=1" style="border:0;" alt="" /></p>
</noscript>
<!-- End mtrcs code -->



<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Define a function to handle the link updates
    const updateLanguageLinks = () => {
      const currentHash = window.location.hash;
      const languageLinks = document.querySelectorAll('a[data-base-url]');

      languageLinks.forEach(link => {
        const baseHref = link.getAttribute('data-base-url');
        link.href = baseHref + currentHash;
      });
    };

    // Initial call when the DOM is ready
    updateLanguageLinks();

    // Listen for hash changes and update the links again
    window.addEventListener('hashchange', updateLanguageLinks);
  });
</script>


<script>
  document.addEventListener('DOMContentLoaded', () => {
    (document.querySelectorAll('.notification .delete') || []).forEach(($delete) => {
      const $notification = $delete.parentNode;

      $delete.addEventListener('click', () => {
        $notification.parentNode.removeChild($notification);
      });
    });
  });
</script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const buttons = document.querySelectorAll('.button');
    const delayBetweenButtons = 400; // 0.2-second stagger
    const animationFrequency = 5000; // 4-second frequency for each button

    buttons.forEach((button, index) => {
      setTimeout(() => {
        setInterval(() => {
          button.classList.add('animated-now');
          setTimeout(() => {
            button.classList.remove('animated-now');
          }, 1000); // Remove class after the 1-second animation completes
        }, animationFrequency);
      }, index * delayBetweenButtons);
    });
  });
</script>


<script>
  // The event listener is essential here because the script is in the <head>
  // and the DOM elements it needs (track, banner) haven't been parsed yet.
  document.addEventListener('DOMContentLoaded', async () => {
    const track = document.querySelector('.scrolling-track');
    const banner = document.querySelector('.scrolling-banner');

    if (!track || !banner) {
      console.warn('Scrolling track or banner element not found. Please ensure the HTML structure is correct.');
      return;
    }

    try {
      const response = await fetch('https://set-outlooksignatures.com/customer-images.txt');
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const text = await response.text();
      let urls = text.split('\n').map(line => line.trim()).filter(Boolean);

      urls = [...new Set(urls)];

      if (urls.length === 0) {
        console.warn('No image URLs found. Banner will not display images.');
        return;
      }

      for (let i = urls.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [urls[i], urls[j]] = [urls[j], urls[i]];
      }

      const originalShuffledUniqueUrls = [...urls];
      const finalUrlsForDOM = [...originalShuffledUniqueUrls, ...originalShuffledUniqueUrls, ...originalShuffledUniqueUrls];

      track.innerHTML = '';
      const imagePromises = finalUrlsForDOM.map(url => {
        return new Promise((resolve) => {
          const img = new Image();
          img.src = url;
          img.alt = `https://${url.split('/').pop()?.split('.').slice(0, -1).join('.')}` || 'Customer Logo';

          img.onload = () => resolve({ img, loaded: true });
          img.onerror = () => {
            console.error(`Failed to load image: ${url}`);
            resolve({ img: null, loaded: false });
          };

          if (img.complete) {
            if (img.naturalHeight > 0) {
              resolve({ img, loaded: true });
            } else {
              resolve({ img: null, loaded: false });
            }
          }
        });
      });

      const loadedImageResults = await Promise.all(imagePromises);
      const imageElements = loadedImageResults.map(result => result.img).filter(img => img !== null);

      if (imageElements.length === 0) {
        console.warn('All images failed to load. Disabling animation.');
        return;
      }

      imageElements.forEach(img => track.appendChild(img));

      requestAnimationFrame(() => {
        const bannerWidth = banner.clientWidth;
        const computedStyle = getComputedStyle(track);
        const gapSize = parseFloat(computedStyle.gap) || 0;

        let scrollDistance = 0;
        for (let i = 0; i < originalShuffledUniqueUrls.length; i++) {
          const img = track.children[i];
          if (img) {
            scrollDistance += img.offsetWidth;
            if (i < originalShuffledUniqueUrls.length - 1) {
              scrollDistance += gapSize;
            }
          }
        }

        if (scrollDistance <= 0 || track.scrollWidth <= bannerWidth + 1) {
          console.warn('Content is not wide enough to scroll. Disabling animation.');
          track.style.animation = 'none';
          return;
        }

        const pixelsPerSecond = 50;
        const animationDuration = scrollDistance / pixelsPerSecond;
        const animationName = 'scroll-full-track-dynamic-' + Date.now();

        let styleSheet = document.getElementById('dynamic-scroll-animation-style');
        if (!styleSheet) {
          styleSheet = document.createElement('style');
          styleSheet.id = 'dynamic-scroll-animation-style';
          document.head.appendChild(styleSheet);
        } else {
          while (styleSheet.sheet && styleSheet.sheet.cssRules.length > 0) {
            styleSheet.sheet.deleteRule(0);
          }
        }

        const keyframesRule = `
          @keyframes ${animationName} {
            from { transform: translateX(0); }
            to { transform: translateX(${-scrollDistance}px); }
          }
        `;
        styleSheet.sheet.insertRule(keyframesRule, styleSheet.sheet.cssRules.length);

        track.style.animation = `${animationName} ${animationDuration}s linear infinite`;
        track.style.animationPlayState = 'running';
      });

    } catch (error) {
      console.error('Failed to fetch or process image URLs:', error);
    }
  });
</script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
  const playerElement = document.getElementById('youtube-video-player');
  if (playerElement) {
    // Define the onYouTubeIframeAPIReady function before loading the script.
    // The YouTube API will call this function automatically once it's loaded.
    window.onYouTubeIframeAPIReady = () => {
      // Create a new YT.Player object for the iframe with id="youtube-video-player"
      window.player = new YT.Player('youtube-video-player', {
        events: {
          'onStateChange': onPlayerStateChange
        }
      });
    };

    // This function is called by the YouTube API whenever the player's state changes.
    function onPlayerStateChange(event) {
      const videoTitle = "Set-OutlookSignatures Demo"; // Customize this
      const currentTime = window.player.getCurrentTime();

      if (event.data === YT.PlayerState.PLAYING) {
        // Track when the video starts playing
        _paq.push(['trackEvent', 'Video', 'Play', videoTitle, Math.round(currentTime)]);
      } else if (event.data === YT.PlayerState.PAUSED) {
        // Track when the video is paused
        _paq.push(['trackEvent', 'Video', 'Pause', videoTitle, Math.round(currentTime)]);
      } else if (event.data === YT.PlayerState.ENDED) {
        // Track when the video ends
        _paq.push(['trackEvent', 'Video', 'Ended', videoTitle, Math.round(currentTime)]);
      }
    }
    
    // Dynamically create and append the script tag to the body.
    // This is the key step that loads the script only when needed.
    const script = document.createElement('script');
    script.src = 'https://www.youtube.com/iframe_api';
    document.body.appendChild(script);
  }
});
</script>