<!-- mtrcs js code -->
<script>
  var _paq = window._paq = window._paq || [];
  _paq.push(["setRequestMethod", "POST"]);
  _paq.push(["disableCookies"]);
  _paq.push(["disableAlwaysUseSendBeacon"]);
  _paq.push(["disableQueueRequest"]);
  _paq.push(["setDocumentTitle", document.domain + ": " + document.title]);
  _paq.push(["setDomains", ["*.set-outlooksignatures.com"]]);
  _paq.push(['enableHeartBeatTimer']);
  _paq.push(['setLinkClasses', ["mtrcs-external-link"]]);
  _paq.push(['setDownloadClasses', ["mtrcs-download"]]);
  _paq.push(['trackPageView']);
  _paq.push(['trackVisibleContentImpressions', true]);
  _paq.push(['enableLinkTracking']);


  (
    function () {
      var u = "https://mtrcs.set-outlooksignatures.com/";
      _paq.push(["setTrackerUrl", u + "mtrcs.php"]);
      _paq.push(["setSiteId", "1"]);
      var d = document;
      g = d.createElement("script");
      s = d.getElementsByTagName("script")[0];
      g.type = "text/javascript";
      g.async = true;
      g.src = u + "mtrcs.js";
      s.parentNode.insertBefore(g, s);
    }
  )();
</script>


<!-- mtrcs no js code -->
<noscript>
  <p>
    <img referrerpolicy="no-referrer-when-downgrade"
      src='//mtrcs.set-outlooksignatures.com/mtrcs.php?idsite=1&rec=1&action_name=page_view&url={{ site.url }}{{ page.url | relative_url }}&rand={{ "now" | date: "%s" }}&apiv=1'
      style="border:0;" alt=""/>
  </p>
</noscript>


<!-- mtrcs youtube code -->
<script>
  document.addEventListener('DOMContentLoaded', async () => {
    const playerElement = document.getElementById('youtube-video-player');
    if (playerElement) {
      // Define the onYouTubeIframeAPIReady function before loading the script.
      // The YouTube API will call this function automatically once it's loaded.
      window.onYouTubeIframeAPIReady = () => {
        // Create a new YT.Player object for the iframe with id="youtube-video-player"
        window.player = new YT.Player('youtube-video-player', {
          events: {
            'onStateChange': onPlayerStateChange
          }
        });
      };

      // This function is called by the YouTube API whenever the player's state changes.
      function onPlayerStateChange(event) {
        const videoTitle = "Set-OutlookSignatures Demo"; // Customize this
        const currentTime = window.player.getCurrentTime();

        if (event.data === YT.PlayerState.PLAYING) {
          // Track when the video starts playing
          _paq.push(['trackEvent', 'Video', 'Play', videoTitle, Math.round(currentTime)]);
        } else if (event.data === YT.PlayerState.PAUSED) {
          // Track when the video is paused
          _paq.push(['trackEvent', 'Video', 'Pause', videoTitle, Math.round(currentTime)]);
        } else if (event.data === YT.PlayerState.ENDED) {
          // Track when the video ends
          _paq.push(['trackEvent', 'Video', 'Ended', videoTitle, Math.round(currentTime)]);
        }
      }

      // Dynamically create and append the script tag to the body.
      // This is the key step that loads the script only when needed.
      const script = document.createElement('script');
      script.src = 'https://www.youtube.com/iframe_api';
      document.body.appendChild(script);
    }
  });
</script>


<!-- Add html hash to language switcher links -->
<script>
  document.addEventListener('DOMContentLoaded', async () => {
    // Define a function to handle the link updates
    const updateLanguageLinks = () => {
      const currentHash = window.location.hash;
      const languageLinks = document.querySelectorAll('a[data-base-url]');

      languageLinks.forEach(link => {
        const baseHref = link.getAttribute('data-base-url');
        link.href = baseHref + currentHash;
      });
    };

    // Initial call when the DOM is ready
    updateLanguageLinks();

    // Listen for hash changes and update the links again
    window.addEventListener('hashchange', updateLanguageLinks);
  });
</script>


<!-- Code for delete button in notifications -->
<script>
  document.addEventListener('DOMContentLoaded', async () => {
    (document.querySelectorAll('.notification .delete') || []).forEach(($delete) => {
      const $notification = $delete.parentNode;

      $delete.addEventListener('click', () => {
        $notification.parentNode.removeChild($notification);
      });
    });
  });
</script>


<!-- Scrolling customer images banner -->
<script>
  document.addEventListener('DOMContentLoaded', async () => {
    const track = document.querySelector('.customer-scrolling-track');
    const banner = document.querySelector('.customer-scrolling-banner');
    const DYNAMIC_CSS_ID = 'customer-dynamic-scroll-animation-style';
    const ANIMATION_NAME = 'customer-scroll-full-track-dynamic';

    if (!track || !banner) {
      console.warn('Scrolling track or banner element not found.');
      return;
    }

    try {
      // --- 1. Fetch and Prepare URLs ---
      const response = await fetch('https://set-outlooksignatures.com/customer-images.txt');
      if (!response.ok) {
        console.error(`HTTP error! status: ${response.status}`);
        return;
      }

      const text = await response.text();
      let urls = [...new Set(
        text.split('\n').map(line => line.trim()).filter(Boolean)
      )];

      if (urls.length === 0) {
        console.warn('No image URLs found. Banner will not display images.');
        return;
      }

      // Fisher-Yates shuffle
      for (let i = urls.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [urls[i], urls[j]] = [urls[j], urls[i]];
      }

      const originalShuffledUrls = urls;
      const finalUrlsForDOM = [...originalShuffledUrls, ...originalShuffledUrls, ...originalShuffledUrls];

      // --- 2. Create and Load Image Elements (Cleaned-up Promise Logic) ---
      track.innerHTML = '';
      const imagePromises = finalUrlsForDOM.map(url => new Promise((resolve) => {
        const img = new Image();
        img.src = url;

        const filename = url.split('/').pop() || '';
        img.alt = filename.split('.').slice(0, -1).join('.') || 'Customer Logo';

        const handleLoad = () => resolve({ img, loaded: true });
        const handleError = () => {
          console.error(`Failed to load image: ${url}`);
          resolve({ img: null, loaded: false });
        };

        // Rely on the event listeners for both fresh and cached images
        img.addEventListener('load', handleLoad, { once: true });
        img.addEventListener('error', handleError, { once: true });
      }));

      const imageElements = (await Promise.all(imagePromises))
        .map(result => result.img)
        .filter(img => img !== null);

      if (imageElements.length === 0) {
        console.warn('All images failed to load. Disabling animation.');
        return;
      }

      imageElements.forEach(img => track.appendChild(img));


      // --- 3. Calculate Scroll Distance and Apply Dynamic Animation (Cleaned-up CSS Insertion) ---
      requestAnimationFrame(() => {
        const bannerWidth = banner.clientWidth;
        const computedStyle = getComputedStyle(track);
        const gapSize = parseFloat(computedStyle.gap) || 0;

        let scrollDistance = 0;
        // Only calculate distance for ONE full set of unique URLs
        for (let i = 0; i < originalShuffledUrls.length; i++) {
          const img = track.children[i];
          if (img) {
            scrollDistance += img.offsetWidth + (i < originalShuffledUrls.length - 1 ? gapSize : 0);
          }
        }

        if (scrollDistance <= 0 || track.scrollWidth <= bannerWidth + 1) {
          console.warn('Content is not wide enough to scroll. Disabling animation.');
          track.style.animation = 'none';
          return;
        }

        const pixelsPerSecond = 50;
        const animationDuration = scrollDistance / pixelsPerSecond;

        // Setup dynamic style sheet
        let styleSheet = document.getElementById(DYNAMIC_CSS_ID);
        if (!styleSheet) {
          styleSheet = document.createElement('style');
          styleSheet.id = DYNAMIC_CSS_ID;
          document.head.appendChild(styleSheet);
        }
        const sheet = styleSheet.sheet;

        // CSS Rule Cleanup
        let ruleIndexToDelete = -1;
        for (let i = 0; i < sheet.cssRules.length; i++) {
          const rule = sheet.cssRules[i];
          if (rule.type === CSSRule.KEYFRAMES_RULE && rule.name === ANIMATION_NAME) {
            ruleIndexToDelete = i;
            break;
          }
        }
        if (ruleIndexToDelete !== -1) sheet.deleteRule(ruleIndexToDelete);

        // Insert new keyframes rule
        const keyframesRule = `@keyframes ${ANIMATION_NAME} { from { transform: translateX(0); } to { transform: translateX(${-scrollDistance}px); } }`;
        sheet.insertRule(keyframesRule, sheet.cssRules.length);

        // Apply animation
        track.style.animation = `${ANIMATION_NAME} ${animationDuration}s linear infinite`;
        track.style.animationPlayState = 'running';
      });

    } catch (error) {
      console.error('Failed to fetch or process image URLs:', error);
    }
  });
</script>


<!-- Scrolling signature images banner -->
<script>
  document.addEventListener('DOMContentLoaded', async () => {
    // Make sure BANNER_HEIGHT is the precise pixel value (e.g., 160)
    const BANNER_HEIGHT = 160; 
    const track = document.querySelector('.signature-scrolling-track');
    const SCROLL_INTERVAL = 1500; 

    // ... (rest of the fetching and setup code remains the same)
    
    // ... (code to create imageElements and append them)
    
      if (imageElements.length === 0) {
        console.warn('All images failed to load. Disabling animation.');
        return;
      }

      imageElements.forEach(img => track.appendChild(img));
      const imageCount = imageElements.length;

      // --- 3. Implement Anti-Drift Vertical Scrolling Logic ---
      let currentIndex = 0;

      const startVerticalScroll = () => {
        // Set the track's transition property once
        track.style.transition = 'transform 0.5s ease-in-out';

        setInterval(() => {
          // 1. Increment the index
          currentIndex++;

          // 2. Use modulo to keep the index within the valid range for the final position
          const nextIndex = currentIndex % imageCount;

          // 3. Calculate the new scroll position (Always a multiple of BANNER_HEIGHT)
          // Use the MODULO value for the actual scroll position to ensure accuracy
          const scrollY = -nextIndex * BANNER_HEIGHT; 
          
          // 4. Temporarily disable transition for the seamless snap
          if (nextIndex === 0) {
              // When snapping from the end back to the start (0), remove the transition
              track.style.transition = 'none';
          }
          
          // 5. Apply the transform
          track.style.transform = `translateY(${scrollY}px)`;

          // 6. Re-enable transition for the next animated scroll
          if (nextIndex === 0) {
              // Re-enable transition on the next frame after the snap
              requestAnimationFrame(() => {
                  track.style.transition = 'transform 0.5s ease-in-out';
              });
          }

        }, SCROLL_INTERVAL);
      };
      
      startVerticalScroll();

    } catch (error) {
      console.error('Failed to fetch or process image URLs:', error);
    }
  });
</script>


<!-- Update download links to latest release of Set-OutlookSignatures -->
<script>
  async function updateDownloadLink() {
    const owner = 'Set-OutlookSignatures';
    const repo = 'Set-OutlookSignatures';
    const repoURL = `https://api.github.com/repos/${owner}/${repo}/releases/latest`;

    try {
      const response = await fetch(repoURL);
      if (!response.ok) {
        throw new Error(`GitHub API request failed with status: ${response.status}`);
      }

      const data = await response.json();
      const firstAsset = data.assets[0];

      if (firstAsset && firstAsset.browser_download_url) {
        const downloadLinks = document.querySelectorAll('.sos-download-link');
        if (downloadLinks.length > 0) {
          downloadLinks.forEach(link => {
            link.href = firstAsset.browser_download_url;
          });
        } else {
          // console.warn('No elements with class "sos-download-link" found.');
        }
      } else {
        console.error('No assets found for the latest release.');
      }
    } catch (error) {
      console.error('Error fetching latest release:', error);
    }
  }

  document.addEventListener('DOMContentLoaded', updateDownloadLink);
</script>


<!-- Add and lazy load background image -->
<style>
  html::before {
    content: "";
    position: fixed;

    /* 1. POSITIONING FOR CENTERING */
    /* Move the top edge to the vertical center */
    top: 50%;
    /* Move the left edge to the horizontal center */
    left: 50%;

    /* 2. RESIZING TO 33% */
    /* Set the width to 33% of the viewport width */
    width: 33vw;
    /* Set the height to 33% of the viewport height */
    height: 33vh;

    /* 3. FINAL ALIGNMENT */
    /* Shifts the element back by half its own width/height to center it */
    transform: translate(-50%, -50%) rotate(-20deg);

    background-repeat: no-repeat;
    background-size: contain;
    background-position: center center;

    pointer-events: none;
    z-index: -2;
    opacity: 0.2;
    filter: var(--bg-filter, none);
  }

  html.loaded::before {
    background-image: url("/assets/images/set-outlooksignatures logo background compressed.png");
  }

  /* Define a new class for dark mode background. This class will be added and removed by JavaScript. */
  html.dark-mode-bg::before {
    --bg-filter: invert(1) hue-rotate(180deg);
  }
</style>

<script>
  /**
   * Standalone script for lazy loading the background image and applying
   * a dark mode filter based on system preference.
   */
  (function () {
    // Use DOMContentLoaded check if you place the script in the <head>
    // If placed before the closing </body> tag, a simple check is usually sufficient.
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initBackgroundLogic);
    } else {
      initBackgroundLogic();
    }

    function initBackgroundLogic() {
      const html = document.documentElement;

      // 1. Lazy Load: Add the 'loaded' class to trigger background-image loading via CSS.
      html.classList.add('loaded');

      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');

      const updateDarkMode = (event) => {
        // event.matches is true if dark mode is preferred
        if (event.matches) {
          html.classList.add('dark-mode-bg');
        } else {
          html.classList.remove('dark-mode-bg');
        }
      };

      // 2. Initial check: Apply the correct state immediately on load.
      updateDarkMode(mediaQuery);

      // 3. Watch for changes in system preference.
      // This is more efficient than polling or unnecessary timers.
      mediaQuery.addEventListener('change', updateDarkMode);
    }
  })();
</script>