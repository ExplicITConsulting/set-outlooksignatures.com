# _plugins/html_modifier_hook.rb
# This plugin modifies the final HTML output of pages/documents by adding
# IDs to headings and inserting anchor links, using a post_render hook.

require 'nokogiri'
require 'set'

module Jekyll
  module HtmlModifierHook
    # This global set tracks all IDs generated by this hook across the entire site.
    # It must use the same ID generation logic as the SearchDataCollector.
    @@all_generated_ids_for_hook = Set.new

    # Register the hook to run after each page/document is fully rendered
    Jekyll::Hooks.register [:pages, :documents], :post_render do |doc|
      # Skip if doc.output is nil or empty (no content), or if it's the search.json page itself,
      # or if it's explicitly excluded from sitemap/indexing, or not an HTML document.
      next if doc.output.nil? || doc.output.empty?
      next if doc.url == '/search.json' || doc.data['sitemap_exclude']
      # Basic check to ensure it's HTML content we can parse (e.g., not a static CSS/JS file)
      next unless doc.output.strip.start_with?('<') || doc.output.strip.start_with?('<!DOCTYPE')

      Jekyll.logger.debug "HtmlModifierHook:", "Processing post_render for: #{doc.url}"

      # Parse the final HTML output (`doc.output`) as an HTML fragment
      doc_fragment = Nokogiri::HTML.fragment(doc.output)

      # Track generated IDs for this specific document during this hook's pass
      document_generated_ids = Set.new

      headings_modified = false # Flag to see if any headings were found and modified

      # Iterate over all heading types (h1 to h6) within the final HTML fragment
      doc_fragment.css('h1, h2, h3, h4, h5, h6').each do |heading_element|
        headings_modified = true
        original_id = heading_element['id']
        final_id = nil

        Jekyll.logger.debug "HtmlModifierHook:", "  Found heading HTML: #{heading_element.to_html.strip.slice(0, 50)}..."
        Jekyll.logger.debug "HtmlModifierHook:", "  Original ID: #{original_id.inspect}"

        # Determine the final ID for the heading (MUST be IDENTICAL logic to SearchDataCollector)
        if original_id && !original_id.empty?
          final_id = original_id
          Jekyll.logger.debug "HtmlModifierHook:", "  Using existing ID: #{final_id}"
        else
          # Call the module method directly using self.slugify or HtmlModifierHook.slugify
          slug_base = HtmlModifierHook.slugify(heading_element.text) 
          unique_slug = slug_base
          counter = 1
          # Ensure uniqueness: first within this document, then globally across IDs generated by this hook
          while document_generated_ids.include?(unique_slug) || @@all_generated_ids_for_hook.include?(unique_slug)
            unique_slug = "#{slug_base}-#{counter}"
            counter += 1
          end
          final_id = unique_slug
          # Assign the generated ID to the HTML element in the DOM
          heading_element['id'] = final_id
          Jekyll.logger.debug "HtmlModifierHook:", "  Generated new ID: #{final_id}"
        end

        # Add the final ID to the sets for uniqueness tracking for this hook
        document_generated_ids.add(final_id)
        @@all_generated_ids_for_hook.add(final_id)

        # Insert the anchor link (ðŸ”—) as the first child of the heading
        anchor = Nokogiri::XML::Node.new "a", doc_fragment # Create anchor node within this fragment's context
        anchor['href'] = "##{final_id}"
        anchor['class'] = "anchor-link"
        anchor.content = "ðŸ”—"
        # heading_element.prepend_child(anchor)
        Jekyll.logger.debug "HtmlModifierHook:", "  Anchor added. Heading now: #{heading_element.to_html.strip.slice(0, 100)}..."
      end

      if headings_modified
        # Update the document's final output (`doc.output`) with the modified HTML fragment
        doc.output = doc_fragment.to_html(encoding: 'UTF-8')
        Jekyll.logger.debug "HtmlModifierHook:", "Finished post_render for: #{doc.url}. Output updated."
      else
        Jekyll.logger.debug "HtmlModifierHook:", "No headings modified in #{doc.url}."
      end
    end

    # Helper function to slugify text (MUST be IDENTICAL to the one in search_data_collector.rb)
    # Defined as a module method (self.slugify) so it can be called on the module.
    def self.slugify(text)
      text.to_s.downcase.strip
        .gsub(/[^a-z0-9\s-]/, '')
        .gsub(/[\s_]+/, '-')
        .gsub(/^-+|-+$/, '')
    end

    # Helper function to strip HTML and normalize whitespace (MUST be IDENTICAL to the one in search_data_collector.rb)
    # Defined as a module method (self.strip_html_and_normalize).
    def self.strip_html_and_normalize(html_content)
      Nokogiri::HTML.fragment(html_content).text
        .gsub(/\s+/, ' ')
        .strip
    end
  end
end